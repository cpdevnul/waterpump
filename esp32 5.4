// =========================================================================
// Includes
// =========================================================================
#include <Wire.h>              // For I2C communication (LCD)
#include <LiquidCrystal_I2C.h> // For I2C LCD display
#include <WiFi.h>              // For ESP32 Wi-Fi
#include <WebServer.h>         // For the Web Server
#include <ArduinoOTA.h>        // For Over-the-Air updates
#include <time.h>              // For time functions (NTP, strftime)
#include <WiFiClientSecure.h>  // For HTTPS communication (IFTTT uses HTTPS)
#include <HTTPClient.h>        // For making HTTP(S) requests
#include <Adafruit_GPS.h>      // Using Adafruit GPS Library
#include <HardwareSerial.h>    // For secondary hardware serial (GPS)
#include <math.h>              // For math functions
#include <stdio.h>             // For snprintf

// =========================================================================
// == CONFIGURATION SECTION ==
// =========================================================================

// --- Hardware Pins ---
#define RELAY_PIN 17    // ESP32 pin GPIO17 that connects to relay
#define MOISTURE_PIN 36 // ESP32 pin GPIO36 (ADC0 / SVP) that connects to AOUT pin of moisture sensor
#define GPS_RX_PIN 16   // ESP32 RX2 pin (Connect to GPS TX)
#define GPS_TX_PIN 4    // ESP32 TX2 pin (Connect to GPS RX)

// --- Moisture Sensor Calibration & Control ---
const int AirValue = 3000;
const int WaterValue = 1110;
const float moistureThresholdDry = 40.0;
const float moistureHysteresis = 5.0;
const int NUM_MOISTURE_SAMPLES = 10;
const int MOISTURE_SAMPLE_DELAY_MS = 10;

// --- Pump Control ---
const unsigned long maxPumpRunTime = 25 * 60 * 1000;

// --- Scheduled Watering Configuration ---
const int SCHEDULED_WATERING_HOUR = 2;
const int SCHEDULED_WATERING_MOISTURE_OVERRIDE = 90;
const unsigned long SCHEDULED_WATERING_DURATION_MS = 20 * 60 * 1000;

// --- Web Server & Manual Control Config ---
#define WEB_SERVER_PORT 80 // Standard HTTP port
const unsigned long MANUAL_WATERING_DURATION_MS = 1 * 60 * 1000; // Run for 1 minute on manual start

// --- LCD Display ---
const int LCD_I2C_ADDR = 0x27;
const int LCD_COLS = 16;
const int LCD_ROWS = 2;

// --- Wi-Fi Credentials ---
const char *ssid = "x";
const char *password = "x!";

// --- IFTTT Webhooks Configuration ---
const char* IFTTT_KEY = "x";
const char* IFTTT_EVENT = "ESP32Watering-Data-backyard1";
String IFTTT_URL_BASE = "https://maker.ifttt.com/trigger/" + String(IFTTT_EVENT) + "/with/key/" + String(IFTTT_KEY);
const unsigned long HTTP_TIMEOUT_MS = 10000;

// --- NTP Time ---
const char* ntpServer = "pool.ntp.org";
const long gmtOffset_sec = -7 * 3600;
const int daylightOffset_sec = 0;

// --- GPS ---
const unsigned long gpsBaud = 9600;

// --- Timing Intervals ---
const long sampleInterval = 10000;
const long timeUpdateInterval = 1000;
const long sheetUpdateInterval = 15 * 60 * 1000;
const unsigned long wifiReconnectInterval = 60 * 1000;

// --- Serial Debug ---
const long SERIAL_BAUD_RATE = 9600;

// =========================================================================
// Global Variables & Objects
// =========================================================================
LiquidCrystal_I2C lcd(LCD_I2C_ADDR, LCD_COLS, LCD_ROWS);
WebServer server(WEB_SERVER_PORT);
HardwareSerial gpsSerial(2);
Adafruit_GPS GPS(&gpsSerial);

// --- State Variables ---
unsigned long lastSampleTime = 0, lastTimeUpdate = 0, lastSheetUpdate = 0, lastWiFiReconnectTime = 0;
unsigned long pumpStartTime = 0;
bool pumpIsRunning = false;
bool wifiConnected = false;
int currentMoisturePercent = -1;
struct tm timeinfo;
char dateTimeStringBuff[20];
char latStr[12], lonStr[12];
bool scheduledWateringDoneToday = false;
bool isScheduledWateringActive = false;
unsigned long scheduledWateringStartTime = 0;
bool isManualWateringActive = false;
unsigned long manualWateringStartTime = 0;

// =========================================================================
// Function Prototypes
// =========================================================================
int readAverageMoisture();
void updateMoistureAndPump(int moisturePercentage, unsigned long currentMillis);
void checkPumpRuntime(unsigned long currentMillis);
bool connectWiFi();
void checkWiFiConnection();
void startOTA();
void updateLCD();
void printLcdPadded(int value, int width);
void handleScheduledWatering();
void handleWateringLogic();
void handleRoot();
void handleManualWater();
void handleStopPump();
void handleStyleCSS();
void handleNotFound();
void setupWebServer();
String getPumpStatusString();
bool sendToIFTTT(String value1, String value2, String value3);


// =========================================================================
// SETUP
// =========================================================================
void setup() {
    Serial.begin(SERIAL_BAUD_RATE);
    while (!Serial && millis() < 2000);
    Serial.println("\n\n=============================");
    Serial.println(" ESP32 Watering System");
    Serial.println(" (+Web Server, +GPS, +Schd) ");
    Serial.println("=============================");

    pinMode(RELAY_PIN, OUTPUT);
    digitalWrite(RELAY_PIN, LOW);
    pinMode(MOISTURE_PIN, INPUT);
    analogSetAttenuation(ADC_11db);

    Wire.begin();
    lcd.init();
    lcd.backlight();
    lcd.clear();
    lcd.setCursor(0, 0); lcd.print("System Starting"); delay(1000);

    gpsSerial.begin(gpsBaud, SERIAL_8N1, GPS_RX_PIN, GPS_TX_PIN);
    GPS.begin(gpsBaud);
    GPS.sendCommand(PMTK_SET_NMEA_OUTPUT_RMCGGA); delay(100);
    GPS.sendCommand(PMTK_SET_NMEA_UPDATE_1HZ); delay(100);

    wifiConnected = connectWiFi();

    if (wifiConnected) {
        configTime(gmtOffset_sec, daylightOffset_sec, ntpServer);
        getLocalTime(&timeinfo, 10000);
        startOTA();
        setupWebServer();
    } else {
        lcd.clear(); lcd.setCursor(0, 0); lcd.print("No WiFi/OTA/WEB"); delay(2000);
    }

    lcd.clear();
    unsigned long initMillis = millis();
    lastSampleTime = initMillis;
    lastTimeUpdate = initMillis;
    lastSheetUpdate = initMillis;
    lastWiFiReconnectTime = initMillis;
    pumpStartTime = 0;
    Serial.println("Setup Complete. Entering Main Loop.");
}

// =========================================================================
// LOOP
// =========================================================================
void loop() {
    if (wifiConnected) {
        ArduinoOTA.handle();
        server.handleClient();
    }

    while (gpsSerial.available() > 0) {
        char c = GPS.read();
        if (GPS.newNMEAreceived()) {
            if (!GPS.parse(GPS.lastNMEA())) { }
        }
    }

    unsigned long currentMillis = millis();
    checkWiFiConnection();
    checkPumpRuntime(currentMillis);
    handleWateringLogic();

    if (currentMillis - lastSampleTime >= sampleInterval) {
        lastSampleTime = currentMillis;
        currentMoisturePercent = readAverageMoisture();
        Serial.printf("Moisture: %d%%\n", currentMoisturePercent);

        if (wifiConnected && (currentMillis - lastSheetUpdate >= sheetUpdateInterval)) {
            lastSheetUpdate = currentMillis;
            String gpsDataString = "";
            if (GPS.fix) {
                snprintf(latStr, sizeof(latStr), "%.6f", GPS.latitudeDegrees);
                snprintf(lonStr, sizeof(lonStr), "%.6f", GPS.longitudeDegrees);
                gpsDataString = String(latStr) + ";" + String(lonStr);
            } else {
                gpsDataString = "No Fix";
            }
            sendToIFTTT("moisture", String(currentMoisturePercent), gpsDataString);
        }
    }

    if (currentMillis - lastTimeUpdate >= timeUpdateInterval) {
        lastTimeUpdate = currentMillis;
        updateLCD();
    }
}

// =========================================================================
// WATERING & SENSOR LOGIC
// =========================================================================

void handleWateringLogic() {
    if (isManualWateringActive) {
        if (millis() - manualWateringStartTime >= MANUAL_WATERING_DURATION_MS) {
            Serial.println("-> Manual watering complete. Turning pump OFF.");
            digitalWrite(RELAY_PIN, LOW);
            pumpIsRunning = false;
            isManualWateringActive = false;
        }
        return;
    }
    handleScheduledWatering();
    if (isScheduledWateringActive) {
        return;
    }
    updateMoistureAndPump(currentMoisturePercent, millis());
}

void handleScheduledWatering() {
    if (isManualWateringActive || !wifiConnected || !getLocalTime(&timeinfo, 0)) return;

    if (timeinfo.tm_hour == (SCHEDULED_WATERING_HOUR - 1) && scheduledWateringDoneToday) {
        scheduledWateringDoneToday = false;
    }

    if (timeinfo.tm_hour == SCHEDULED_WATERING_HOUR && !scheduledWateringDoneToday && !pumpIsRunning) {
        scheduledWateringDoneToday = true;
        Serial.printf("\nIt's %02d:00. Checking for scheduled watering.\n", SCHEDULED_WATERING_HOUR);
        if (currentMoisturePercent >= SCHEDULED_WATERING_MOISTURE_OVERRIDE) {
            Serial.println("-> Moisture is high. SKIPPING scheduled watering.");
        } else {
            Serial.println("-> Moisture is low. STARTING 20-minute scheduled watering.");
            isScheduledWateringActive = true;
            scheduledWateringStartTime = millis();
            pumpIsRunning = true;
            digitalWrite(RELAY_PIN, HIGH);
        }
    }
    
    if (isScheduledWateringActive && (millis() - scheduledWateringStartTime >= SCHEDULED_WATERING_DURATION_MS)) {
        Serial.println("-> Scheduled watering complete. Turning pump OFF.");
        isScheduledWateringActive = false;
        pumpIsRunning = false;
        digitalWrite(RELAY_PIN, LOW);
    }
}

void updateMoistureAndPump(int moisturePercentage, unsigned long currentMillis) {
    if (moisturePercentage < 0) return;

    if (moisturePercentage < moistureThresholdDry && !pumpIsRunning) {
        Serial.println("-> Moisture below threshold. Turning Pump ON.");
        digitalWrite(RELAY_PIN, HIGH);
        pumpIsRunning = true;
        pumpStartTime = currentMillis;
    } else if (moisturePercentage >= (moistureThresholdDry + moistureHysteresis) && pumpIsRunning) {
        Serial.println("-> Moisture above threshold + hysteresis. Turning Pump OFF.");
        digitalWrite(RELAY_PIN, LOW);
        pumpIsRunning = false;
        unsigned long durationMillis = (pumpStartTime > 0) ? (currentMillis - pumpStartTime) : 0;
        
        if (wifiConnected && durationMillis > 0) {
            float durationSec = durationMillis / 1000.0;
            String gpsDataStringPump = GPS.fix ? (String(GPS.latitudeDegrees, 6) + ";" + String(GPS.longitudeDegrees, 6)) : "No Fix";
            sendToIFTTT("pumpOff", String(durationSec, 1), gpsDataStringPump);
        }
        pumpStartTime = 0;
    }
}

int readAverageMoisture() {
    long totalValue = 0;
    for (int i = 0; i < NUM_MOISTURE_SAMPLES; i++) {
        totalValue += analogRead(MOISTURE_PIN);
        delay(MOISTURE_SAMPLE_DELAY_MS);
    }
    int avgValue = totalValue / NUM_MOISTURE_SAMPLES;
    int percentage = map(avgValue, AirValue, WaterValue, 0, 100);
    return constrain(percentage, 0, 100);
}

void checkPumpRuntime(unsigned long currentMillis) {
    if (pumpIsRunning && pumpStartTime > 0) {
        if (currentMillis - pumpStartTime >= maxPumpRunTime) {
            Serial.println("\n!!! Max pump runtime reached. Forcing Pump OFF. !!!");
            digitalWrite(RELAY_PIN, LOW);
            pumpIsRunning = false;
            pumpStartTime = 0;
            if (isScheduledWateringActive) {
                isScheduledWateringActive = false;
                Serial.println("!!! (The active scheduled watering cycle was terminated) !!!");
            }
            if(isManualWateringActive){
                isManualWateringActive = false;
                Serial.println("!!! (The active manual watering cycle was terminated) !!!");
            }
            lcd.clear();
            lcd.setCursor(0, 0); lcd.print("Pump Runtime");
            lcd.setCursor(0, 1); lcd.print("Limit Reached!");
            delay(3000);
            lcd.clear();
            lastTimeUpdate = 0;
        }
    }
}

// =========================================================================
// WEB SERVER FUNCTIONS
// =========================================================================

void setupWebServer() {
    server.on("/", HTTP_GET, handleRoot);
    server.on("/style.css", HTTP_GET, handleStyleCSS);
    server.on("/manual_water", HTTP_GET, handleManualWater);
    server.on("/stop_pump", HTTP_GET, handleStopPump);
    server.onNotFound(handleNotFound);
    server.begin();
    Serial.println("Web Server started on port " + String(WEB_SERVER_PORT));
}

void handleRoot() {
    String html = "<!DOCTYPE html><html><head><title>ESP32 Watering System</title>";
    html += "<meta name='viewport' content='width=device-width, initial-scale=1'>";
    html += "<meta http-equiv='refresh' content='5'>";
    html += "<link rel='stylesheet' type='text/css' href='/style.css'>";
    html += "</head><body><div class='container'>";
    html += "<h1>ESP32 Watering System</h1>";
    html += "<div class='card status'><h2>System Status</h2>";
    html += "<p><strong>Soil Moisture:</strong> " + String(currentMoisturePercent) + "%</p>";
    html += "<p><strong>Pump Status:</strong> " + getPumpStatusString() + "</p>";
    getLocalTime(&timeinfo, 0);
    strftime(dateTimeStringBuff, sizeof(dateTimeStringBuff), "%A, %H:%M:%S", &timeinfo);
    html += "<p><strong>System Time:</strong> " + String(dateTimeStringBuff) + "</p>";
    html += "<p><strong>GPS Fix:</strong> " + (GPS.fix ? "Yes (" + String(GPS.satellites) + " satellites)" : "No") + "</p>";
    html += "</div>";
    html += "<div class='card controls'><h2>Manual Controls</h2>";
    html += pumpIsRunning ? "<a href='/stop_pump' class='button btn-stop'>Force Stop Pump</a>" : "<a href='/manual_water' class='button btn-start'>Manual Water (1 min)</a>";
    html += "</div></div></body></html>";
    server.send(200, "text/html", html);
}

void handleManualWater() {
    Serial.println("Web request: Manual water started.");
    if (!pumpIsRunning) {
        isManualWateringActive = true;
        manualWateringStartTime = millis();
        pumpIsRunning = true;
        digitalWrite(RELAY_PIN, HIGH);
    }
    server.sendHeader("Location", "/");
    server.send(302, "text/plain", "Redirecting...");
}

void handleStopPump() {
    Serial.println("Web request: Forced stop.");
    digitalWrite(RELAY_PIN, LOW);
    pumpIsRunning = false;
    isManualWateringActive = false;
    isScheduledWateringActive = false;
    pumpStartTime = 0;
    server.sendHeader("Location", "/");
    server.send(302, "text/plain", "Redirecting...");
}

void handleStyleCSS() {
    String css = "body{font-family:sans-serif;background-color:#f0f2f5;color:#333;display:flex;justify-content:center;margin-top:20px;}";
    css += ".container{width:90%;max-width:600px;}";
    css += ".card{background-color:white;border-radius:8px;box-shadow:0 2px 4px rgba(0,0,0,0.1);padding:20px;margin-bottom:20px;}";
    css += "h1,h2{color:#005685;text-align:center;} h1{margin-bottom:30px;} h2{margin-top:0;}";
    css += ".status p{margin:10px 0;font-size:1.1em;}";
    css += ".button{display:block;text-align:center;padding:15px;border-radius:5px;text-decoration:none;color:white;font-size:1.2em;font-weight:bold;}";
    css += ".btn-start{background-color:#28a745;} .btn-start:hover{background-color:#218838;}";
    css += ".btn-stop{background-color:#dc3545;} .btn-stop:hover{background-color:#c82333;}";
    server.send(200, "text/css", css);
}

void handleNotFound() {
    server.send(404, "text/plain", "404: Not Found");
}

String getPumpStatusString() {
    if (isManualWateringActive) return "ON (Manual)";
    if (isScheduledWateringActive) return "ON (Scheduled)";
    if (pumpIsRunning) return "ON (Moisture)";
    if (currentMoisturePercent >= moistureThresholdDry) return "OFF (Moisture OK)";
    return "OFF (Idle)";
}

// =========================================================================
// UTILITIES & OTHER FUNCTIONS
// =========================================================================

void updateLCD() {
    lcd.setCursor(0, 0);
    lcd.print("Moist:");
    if (currentMoisturePercent >= 0) { printLcdPadded(currentMoisturePercent, 3); lcd.print("%"); }
    else { lcd.print("---%"); }
    lcd.print(" S:");
    if (GPS.fix) { printLcdPadded(GPS.satellites, 2); } else { lcd.print("--"); }

    lcd.setCursor(0, 1);
    if (wifiConnected && getLocalTime(&timeinfo, 0)) {
        strftime(dateTimeStringBuff, sizeof(dateTimeStringBuff), "%H:%M:%S", &timeinfo);
        lcd.print(dateTimeStringBuff);
    } else { lcd.print("--:--:--"); }

    lcd.print(" Pmp:");
    if (isManualWateringActive) { lcd.print("MANL"); }
    else if (isScheduledWateringActive) { lcd.print("SCHD"); }
    else { lcd.print(pumpIsRunning ? "ON  " : "OFF "); }
}

void printLcdPadded(int value, int width) {
    char format[10];
    char buffer[10];
    snprintf(format, sizeof(format), "%%%dd", width);
    snprintf(buffer, sizeof(buffer), format, value);
    lcd.print(buffer);
}

bool connectWiFi() {
    WiFi.mode(WIFI_STA);
    WiFi.begin(ssid, password);
    Serial.print("\nConnecting to WiFi SSID: "); Serial.println(ssid);
    int attempts = 0;
    while (WiFi.status() != WL_CONNECTED && attempts < 20) {
        delay(500);
        Serial.print(".");
        attempts++;
    }
    if (WiFi.status() == WL_CONNECTED) {
        Serial.println("\nWiFi connected!");
        Serial.print("IP address: "); Serial.println(WiFi.localIP());
        return true;
    }
    Serial.println("\nFailed to connect to WiFi.");
    return false;
}

void checkWiFiConnection() {
    if (WiFi.status() != WL_CONNECTED) {
        if (millis() - lastWiFiReconnectTime >= wifiReconnectInterval) {
            lastWiFiReconnectTime = millis();
            Serial.println("\nWiFi connection lost. Attempting to reconnect...");
            connectWiFi();
        }
    }
}

void startOTA() {
    ArduinoOTA.setHostname("ESP32-Watering-System");
    ArduinoOTA.onStart([]() { Serial.println("Start updating sketch"); });
    ArduinoOTA.onEnd([]() { Serial.println("\nEnd"); });
    ArduinoOTA.onProgress([](unsigned int progress, unsigned int total) { Serial.printf("Progress: %u%%\r", (progress / (total / 100))); });
    ArduinoOTA.onError([](ota_error_t error) {
        Serial.printf("Error[%u]: ", error);
        if (error == OTA_AUTH_ERROR) Serial.println("Auth Failed");
        else if (error == OTA_BEGIN_ERROR) Serial.println("Begin Failed");
        else if (error == OTA_CONNECT_ERROR) Serial.println("Connect Failed");
        else if (error == OTA_RECEIVE_ERROR) Serial.println("Receive Failed");
        else if (error == OTA_END_ERROR) Serial.println("End Failed");
    });
    ArduinoOTA.begin();
    Serial.println("OTA Ready");
}

bool sendToIFTTT(String value1, String value2, String value3) {
    if (!wifiConnected) return false;
    bool success = false;
    WiFiClientSecure client;
    HTTPClient http;
    client.setInsecure(); // Use for convenience, less secure

    if (http.begin(client, IFTTT_URL_BASE)) {
        http.addHeader("Content-Type", "application/json");
        http.setTimeout(HTTP_TIMEOUT_MS);
        String jsonPayload = "{\"value1\":\"" + value1 + "\",\"value2\":\"" + value2 + "\",\"value3\":\"" + value3 + "\"}";
        int httpCode = http.POST(jsonPayload);
        if (httpCode == HTTP_CODE_OK) {
            success = true;
            Serial.println("IFTTT event sent successfully.");
        } else {
            Serial.printf("IFTTT send failed, error: %s\n", http.errorToString(httpCode).c_str());
        }
        http.end();
    } else {
        Serial.println("IFTTT: Unable to connect.");
    }
    return success;
}
